"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTlsMqttClient = createTlsMqttClient;

var _mqtt = _interopRequireDefault(require("mqtt"));

var _tls = _interopRequireDefault(require("tls"));

var _fs = _interopRequireDefault(require("fs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function tlsConnection(options) {
  const ca = options.ca || _fs.default.readFileSync(options.caPath);

  const key = options.key || _fs.default.readFileSync(options.keyPath);

  const cert = options.cert || _fs.default.readFileSync(options.certPath);

  const mqttClientOptions = {
    port: 8883,
    enableTrace: false,
    requestCert: true,
    rejectUnauthorized: true,
    ...options,
    ca,
    key,
    cert
  };
  return mqttClient => {
    const tlsConnection = _tls.default.connect(mqttClientOptions);

    function handleTLSerrors(err) {
      mqttClient.emit('error', err);
      tlsConnection.end();
    }

    tlsConnection.on('secureConnect', () => {
      if (!tlsConnection.authorized) tlsConnection.emit('error', new Error('TLS not authorized'));else tlsConnection.removeListener('error', handleTLSerrors);
    });
    tlsConnection.on('error', handleTLSerrors);
    return tlsConnection;
  };
}

function createTlsMqttClient(options) {
  const tlsConnector = tlsConnection(options);
  return new _mqtt.default.MqttClient(tlsConnector, options);
}